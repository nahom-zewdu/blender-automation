# mvp/engine_v1_scene_builder.py
""" script to build the scene in Blender based on the manifest generated by the planner. """

import bpy
import json
import os
from mathutils import Vector
# CONFIG
ASSETS_ROOT = "assets"
MANIFEST_PATH = os.path.join(ASSETS_ROOT, "manifests", "scene_auto.scene.json")

ASSET_FILES = {
    "kid_1": "kid.glb",
    "ball_1": "ball.glb",
    "court_1": "court.glb"
}

# Target real-world sizes (meters)
TARGET_SIZES = {
    "kid_1": 1.2,     # height
    "ball_1": 0.24,   # diameter
    "court_1": 15.0   # width
}

# RESET SCENE
bpy.ops.wm.read_factory_settings(use_empty=True)

# IMPORT
def import_asset(filepath):
    before = set(bpy.data.objects)

    if filepath.lower().endswith(".fbx"):
        bpy.ops.import_scene.fbx(filepath=filepath)
    elif filepath.lower().endswith(".glb") or filepath.lower().endswith(".gltf"):
        bpy.ops.import_scene.gltf(filepath=filepath)
    else:
        raise Exception("Unsupported format")

    after = set(bpy.data.objects)
    return list(after - before)


def wrap_asset(asset_id, objects):
    root_name = f"ASSET_{asset_id.upper()}"
    root = bpy.data.objects.new(root_name, None)
    bpy.context.scene.collection.objects.link(root)

    for obj in objects:
        if obj.parent is None:
            obj.parent = root

    return root

# BOUNDING BOX
def get_combined_bbox(obj):
    meshes = [o for o in obj.children_recursive if o.type == 'MESH']
    if not meshes:
        return None

    min_v = Vector((1e9, 1e9, 1e9))
    max_v = Vector((-1e9, -1e9, -1e9))

    for m in meshes:
        for corner in m.bound_box:
            world_corner = m.matrix_world @ Vector(corner)
            min_v = Vector(map(min, min_v, world_corner))
            max_v = Vector(map(max, max_v, world_corner))

    return min_v, max_v

# NORMALIZE SCALE
def normalize_asset(root, asset_id):
    bpy.context.view_layer.update()

    bbox = get_combined_bbox(root)
    if not bbox:
        return

    min_v, max_v = bbox
    size_vec = max_v - min_v

    if asset_id == "court_1":
        current_size = max(size_vec.x, size_vec.y)
    else:
        current_size = size_vec.z

    if current_size == 0:
        return

    target = TARGET_SIZES.get(asset_id)
    if not target:
        return

    scale_factor = target / current_size
    root.scale *= scale_factor

    bpy.context.view_layer.update()
    print(f"Normalized {asset_id} scale â†’ factor {scale_factor:.3f}")

# LOAD SCENE MANIFEST
with open(MANIFEST_PATH) as f:
    scene_manifest = json.load(f)

# IMPORT ALL ASSETS
ASSETS = {}

for asset_id, asset_data in scene_manifest["assets"].items():

    filepath = os.path.join(ASSETS_ROOT, ASSET_FILES[asset_id])
    print("Importing:", filepath)

    objs = import_asset(filepath)
    root = wrap_asset(asset_id, objs)

    # Normalize BEFORE placement
    normalize_asset(root, asset_id)

    # Apply placement
    root.location = Vector(asset_data["location"])

    ASSETS[asset_id] = root

# SET FRAME RANGE
bpy.context.scene.frame_start = scene_manifest["frame_start"]
bpy.context.scene.frame_end = scene_manifest["frame_end"]

# APPLY ANIMATIONS
def animate_linear_move(obj, start, end, f1, f2):
    obj.location = Vector(start)
    obj.keyframe_insert(data_path="location", frame=f1)

    obj.location = Vector(end)
    obj.keyframe_insert(data_path="location", frame=f2)


for anim in scene_manifest.get("animations", []):

    obj = ASSETS[anim["asset_id"]]

    if anim["type"] == "linear_move":
        animate_linear_move(
            obj,
            anim["start"],
            anim["end"],
            anim["frames"][0],
            anim["frames"][1]
        )

print("\nScene Rebuilt Successfully")
